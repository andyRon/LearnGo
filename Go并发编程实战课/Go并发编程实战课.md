Go并发编程实战课
----

[《Go并发编程实战课》](https://time.geekbang.org/column/intro/100061801)



![](images/74b053f21239d7b10b94638cb23eefb1.jpg)





# 一、基本并发原语

传统的并发原语：Mutex、RWMutex、Waitgroup、Cond、Pool、Context等标准库中的并发原语。这些在其它语言中也很常见。

## 1 Mutex：如何解决资源并发访问问题？

### 互斥锁的实现机制

![](images/image-20250221003140792.png)



同步原语的适用场景：

- 共享资源。并发地读写共享资源，会出现数据竞争（data race）的问题，所以需要Mutex、RWMutex这样的并发原语来保护。
- 任务编排。需要goroutine按照一定的规律执行，而goroutine之间有相互等待或者依赖的顺序关系，我们常常使用WaitGroup或者Channel来实现。
- 消息传递。信息交流以及不同的goroutine之间的线程安全的数据交流，常常使用Channel来实现。

### Mutex的基本使用方法







## 2 Mutex：庖丁解牛看实现

![](images/image-20250221003332269.png)

### 初版的互斥锁



### 给新人机会



### 多给些机会





### 解决饥饿



### 饥饿模式和正常模式









## 3 Mutex：4种易错场景大盘点



## 4 Mutex：骇客编程，如何拓展额外功能？





![](images/00030.jpeg)



## 5 RWMutex：读写锁的实现原理及避坑指南



![](images/image-20250221004031246.png)

## 6 WaitGroup：协同等待，任务编排利器



![](images/image-20250221004119175.png)

## 7 Cond：条件变量的实现机制及避坑指南



![](images/image-20250221004156640.png)

## 8 Once：一个简约而不简单的并发原语



![](images/image-20250221004227693.png)



## 9 map：如何实现线程安全的map类型？



![](images/image-20250221004310764.png)



## 10 Pool：性能提升大杀器



![](images/image-20250221004351153.png)



## 11 Context：信息穿透上下文



![](images/image-20250221004459539.png)



# 二、原子操作

Go标准库中提供的原子操作。原子操作是其它并发原语的基础，学会了就可以自己创造新的并发原语。

## 12 atomic：要保证原子操作，一定要使用这几种方法



![](images/image-20250221004556161.png)



# 三、Channel

Channel类型是Go语言独特的类型，因为比较新，所以难以掌握。

不仅能掌握它的基本用法，而且还能掌握它的处理场景和应用模式，避免踩坑。

## 13 Channel：另辟蹊径，解决并发问题





## 14 Channel：透过代码看典型的应用模式



![](images/image-20250221004656361.jpeg)

## 15 内存模型：Go如何保证并发读写的顺序？



![](images/image-20250221004905187.png)



# 四、扩展并发原语

想进一步提升并发编程能力，就需要学习一些第三方库。

## 16 Semaphore：一篇文章搞懂信号量

### 信号量是什么？都有什么操作？

信号量的概念是荷兰计算机科学家Edsger Dijkstra在1963年左右提出来的，广泛应用在不同的操作系统中。在系统中，会给每一个进程一个信号量，代表每个进程目前的状态。未得到控制权的进程，会在特定的地方被迫停下来，等待可以继续进行的信号到来。

最简单的信号量就是一个变量加一些并发控制的能力，这个变量是0到n之间的一个数值。当goroutine完成对此信号量的等待（wait）时，该计数值就减1，当goroutine完成对此信号量的释放（release）时，该计数值就加1。当计数值为0的时候，goroutine调用wait等待该信号量是不会成功的，除非计数器又大于0，等待的goroutine才有可能成功返回。



### P/V操作



### Go官方扩展库的实现



### 使用信号量的常见错误



### 其它信号量的实现





![](images/image-20250221150814734.png)





## 17 SingleFlight 和 CyclicBarrier：请求合并和循环栅栏该怎么用？

SingleFlight的作用是将并发请求合并成一个请求，以减少对下层服务的压力；

而CyclicBarrier是一个可重用的栅栏并发原语，用来控制一组请求同时执行的数据结构。

### 请求合并SingleFlight



### 循环栅栏CyclicBarrier



![](images/image-20250221150929766.png)



![](images/image-20250221150956184.png)



## 18 分组操作：处理一组子任务，该用什么并发原语？

分组编排的一些常用场景和并发原语，包括ErrGroup、gollback、Hunch和schedgroup。

### ErrGroup





![](images/image-20250221151212744.png)







# 五、分布式并发原语

分布式并发原语是应对大规模的应用程序中并发问题的并发类型。

介绍使用etcd实现的一些分布式并发原语，比如**Leader选举、分布式互斥锁、分布式读写锁、分布式队列**等，在处理分布式场景的并发问题时，特别有用。

## 19 在分布式环境中，Leader选举、互斥锁和读写锁该如何实现？

常用来做协调工作的软件系统是Zookeeper、etcd、Consul之类的软件，Zookeeper为Java生态群提供了丰富的分布式并发原语（通过Curator库），但是缺少Go相关的并发原语库。Consul在提供分布式并发原语这件事儿上不是很积极，而etcd就提供了非常好的分布式并发原语，比如分布式互斥锁、分布式读写锁、Leader选举，等等。

### Leader选举



![](images/image-20250221151326400.png)





### 互斥锁





### 读写锁



![](images/image-20250221151409043.png)



## 20 在分布式环境中，队列、栅栏和STM该如何实现？

### 分布式队列和优先级队列



### 分布式栅栏



### Barrier：分布式栅栏



### DoubleBarrier：计数型栅栏



### STM



![](images/image-20250221151716047.png)



## Go并发编程的价值和精进之路
Go并发编程实战课
----

[《Go并发编程实战课》](https://time.geekbang.org/column/intro/100061801)



![](images/74b053f21239d7b10b94638cb23eefb1.jpg)





# 一、基本并发原语

传统的并发原语：Mutex、RWMutex、Waitgroup、Cond、Pool、Context等标准库中的并发原语。这些在其它语言中也很常见。

## 1 Mutex：如何解决资源并发访问问题？

### 互斥锁的实现机制

![](images/image-20250221003140792.png)



同步原语的适用场景：

- 共享资源。并发地读写共享资源，会出现数据竞争（data race）的问题，所以需要Mutex、RWMutex这样的并发原语来保护。
- 任务编排。需要goroutine按照一定的规律执行，而goroutine之间有相互等待或者依赖的顺序关系，我们常常使用WaitGroup或者Channel来实现。
- 消息传递。信息交流以及不同的goroutine之间的线程安全的数据交流，常常使用Channel来实现。

### Mutex的基本使用方法







## 2 Mutex：庖丁解牛看实现

![](images/image-20250221003332269.png)

### 初版的互斥锁



### 给新人机会



### 多给些机会





### 解决饥饿



### 饥饿模式和正常模式









## 3 Mutex：4种易错场景大盘点



## 4 Mutex：骇客编程，如何拓展额外功能？





![](images/00030.jpeg)



## 5 RWMutex：读写锁的实现原理及避坑指南



![](images/image-20250221004031246.png)

## 6 WaitGroup：协同等待，任务编排利器



![](images/image-20250221004119175.png)

## 7 Cond：条件变量的实现机制及避坑指南



![](images/image-20250221004156640.png)

## 8 Once：一个简约而不简单的并发原语



![](images/image-20250221004227693.png)



## 9 map：如何实现线程安全的map类型？



![](images/image-20250221004310764.png)



## 10 Pool：性能提升大杀器



![](images/image-20250221004351153.png)



## 11 Context：信息穿透上下文



![](images/image-20250221004459539.png)



# 二、原子操作

Go标准库中提供的原子操作。原子操作是其它并发原语的基础，学会了就可以自己创造新的并发原语。

## 12 atomic：要保证原子操作，一定要使用这几种方法



![](images/image-20250221004556161.png)



# 三、Channel

Channel类型是Go语言独特的类型，因为比较新，所以难以掌握。

不仅能掌握它的基本用法，而且还能掌握它的处理场景和应用模式，避免踩坑。

## 13 Channel：另辟蹊径，解决并发问题





## 14 Channel：透过代码看典型的应用模式



![](images/image-20250221004656361.jpeg)

## 15 内存模型：Go如何保证并发读写的顺序？



![](images/image-20250221004905187.png)



# 四、扩展并发原语

## 16 Semaphore：一篇文章搞懂信号量



## 17 SingleFlight 和 CyclicBarrier：请求合并和循环栅栏该怎么用？



## 18 分组操作：处理一组子任务，该用什么并发原语？





# 五、分布式并发原语

分布式并发原语是应对大规模的应用程序中并发问题的并发类型。

介绍使用etcd实现的一些分布式并发原语，比如**Leader选举、分布式互斥锁、分布式读写锁、分布式队列**等，在处理分布式场景的并发问题时，特别有用。

## 19 在分布式环境中，Leader选举、互斥锁和读写锁该如何实现？



## 20 在分布式环境中，队列、栅栏和STM该如何实现？





## Go并发编程的价值和精进之路